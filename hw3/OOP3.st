Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'subclass creation' stamp: 'adan 3/3/2024 16:35'!subclass: sName instanceVariableNames: instVarsclassVariableNames: cVars poolDictionaries: pDictcategory: cat| subC |(self isInterface)	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].subC :=(ClassBuilder new)		superclass: self		subclass: sName		instanceVariableNames: instVars		classVariableNames: cVars		poolDictionaries: pDict		category: cat.		subC instVarNamed: 'isInterface' put: false.subC instVarNamed: 'behavesLike' put: {}. "(self behavesLike). "^subC.! !!MyObject class methodsFor: 'subclass creation' stamp: 'adan 3/3/2024 23:10'!subclass: sName isInterface: isInterface behavesLike:behLikeSet instanceVariableNames: instVars classVariableNames:cVars poolDictionaries: pDict category: cat| subC |(isInterface and:[(((self class)asString = 'MyObject class')not)]) 	ifTrue:[AssertionFailure signal: 'Interfaces must derive from MyObject!!'].	(isInterface and:[ ((instVars = '') not )]) 	ifTrue:[AssertionFailure signal: 'Interfaces can not have state!!'].(isInterface == false and:[self isInterface])	ifTrue:[AssertionFailure signal: 'Classes can not derive from an interface!!'].behLikeSet do: [:cl | 	(cl isInterface)	 ifFalse:[AssertionFailure signal:'Can not behave like a non-interface!!'] 	].subC := self subclass: sName instanceVariableNames: instVarsclassVariableNames: cVars poolDictionaries: pDictcategory: cat.subC instVarNamed: 'behavesLike' put: (behLikeSet asSet).subC instVarNamed: 'isInterface' put: isInterface.^subC.! !!MyObject class methodsFor: 'initialize-release' stamp: 'adan 3/3/2024 20:53'!isInterface	^isInterface.! !!MyObject class methodsFor: 'compiling' stamp: 'adan 3/3/2024 22:47'!compile: aSourceCode| isEmp |isEmp:= (self checkEmptyFunction: aSourceCode)."interfaces should only have empty methods"((self isInterface) and:[isEmp = false])	ifTrue:[AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'].^self compile: aSourceCode notifying: nil.! !!MyObject class methodsFor: 'compiling' stamp: 'adan 3/3/2024 23:11'!compile: aSourceCode where: anOrderedCollection|isEmptyFunc codeFirstLn codeSecondLn codeStream innerCode containsVars args firstLnArgs ii newCode typesCheck errorFlag errorStr|		"check if the function is empty, if it is an interface it HAS TO be empty"	isEmptyFunc := (self checkEmptyFunction: aSourceCode).	((self isInterface) and:[isEmptyFunc not])	ifTrue: [		"TODO: return an error-------------------------------------------------------------------------------------------------------------------------------------------------------------------"		AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'.		].		newCode := String new.	codeFirstLn := String new.	codeSecondLn := String new.	innerCode := String new.	containsVars := true.			codeStream := aSourceCode readStream.	codeFirstLn := codeStream nextLine. "the first line is supposed to be the name of the method and its parameters"	codeSecondLn := codeStream nextLine. "the second line could either be the start of the code or the local variables"		"check if there are any local variables and find out where the code starts"	(codeSecondLn includes: $| )	ifTrue: ["this means we have local vairiables so the code starts at line 3" |index| 		containsVars := true.		index := 0.		aSourceCode linesDo: [:curLine| 			index := index+1.			(index > 2)			ifTrue:[ innerCode := innerCode , curLine.]			].		]	ifFalse:["this means we don't have local vairiables so the code starts at line 2"|index| 		containsVars := false.		index := 0.		aSourceCode linesDo: [:curLine| index := index+1.			(index > 1)			ifTrue:[ innerCode := innerCode , curLine.]			].		].		"extract the arguments "	args := OrderedCollection new.	firstLnArgs := OrderedCollection new.	firstLnArgs := codeFirstLn findTokens: ': '.	ii := 0.	firstLnArgs do:[ :each |		ii := ii+1.		( (ii\\2) = 0 )		ifTrue:[			args addLast: each.			] 		].		typesCheck := String new.		"check if the sizes are equal"	((anOrderedCollection size ) = (args size))	ifFalse:[	AssertionFailure signal:  'Can not compile method, number of arguments is not equal to the number of constraints!!'.	].	"no arguments were found "	(args isEmpty)	ifTrue: [		^self compile: aSourceCode notifying: nil.		].	"we should return an error of the first mismatch that we find, so errorFlag and errorStr help us find the first error"	errorFlag := false.	errorStr := String new.	"we want the typesCheck string to look like: ((arg1 isKindOf: class1) and: [arg2 isKindOf: class2] and: [arg3 isKindOf: class3]) ifFalse: [return error ]."	typesCheck := '( (' , (args at:1), ' isKindOf: ', (anOrderedCollection at: 1), ')'.	ii := 0.	args do: [ :eachArg |		ii := ii + 1.		(ii > 1)		ifTrue:[			(((anOrderedCollection at: ii) = nil )not)			ifTrue:[			((args at:ii) isKindOf:  (anOrderedCollection at: ii))			ifTrue:[			typesCheck :=  typesCheck , ' and: [' , (args at:ii), ' isKindOf: ', (anOrderedCollection at: ii), ']'.						]			ifFalse:[			typesCheck :=  typesCheck , ' and: [' , (args at:ii), ' isKindOf: ', (anOrderedCollection at: ii), ']'.			(errorFlag)			ifTrue:[			errorFlag := true.			errorStr :=  'ifFalse: [AssertionFailure signal: '' ', 'Type mismatch!!!! Argument ', ii, ' should be ' , (anOrderedCollection at: ii) , ''' ].'.			] .		]]] ].	typesCheck := typesCheck , ')'.	typesCheck := typesCheck , Character cr.		"if no errors were found, ad this just to complete the if condition, but it will never happen"	(errorFlag)			ifFalse:[			errorFlag := true.			errorStr :=  'ifFalse: [AssertionFailure signal: '' ', 'Type mismatch!!!! Argument ', ii, ' should be ' , (anOrderedCollection at: ii) , ''' ].'.			] .		typesCheck := typesCheck , errorStr.		(containsVars)	ifTrue:[		newCode := codeFirstLn , Character cr, codeSecondLn, Character cr, typesCheck, Character cr, innerCode.		]	ifFalse:[		newCode := codeFirstLn , Character cr, typesCheck, Character cr, innerCode.		].		^self compile: newCode notifying: nil.! !!MyObject class methodsFor: 'comparing' stamp: 'adan 3/3/2024 14:25'!checkEmptyFunction: aSourceCode	|index |		"this method, recieves a source code for a function/method, and it checks if it is empty (aka has no codeinside)"	index := 0.	"traverse the lines of the code, if you reached line 2 and it is empty, return that the method is empty, otherwise false"	aSourceCode linesDo: [:curLine| index := index+1.].	(index = 1)	ifTrue: [^true]	ifFalse: [^false].	! !!MyObject class methodsFor: 'instance creation' stamp: 'adan 3/3/2024 14:39'!new(self isInterface)	 ifTrue:[AssertionFailure signal: 'Interfaces can not be instantiated!!'].^ self basicNew initialize.! !!MyObject class methodsFor: 'class methods' stamp: 'adan 3/3/2024 16:43'!ambiguities	| res resDup behavesLikeSet |			res := Set new." here we save the result - contains methods"	resDup := Set new. "we need this in order to do both add and do simultaniousley - contains methods"	behavesLikeSet := Set new. "a set of all the interfaces that self bhaves like - recursivley "	behavesLikeSet := self behavesLike.			behavesLikeSet do: [ :fazaClass  |			(fazaClass methodDictionary keys) do:[ :fazaMethod|				(resDup includes: fazaMethod)				ifTrue:[					res add: fazaMethod.										].				].						resDup addAll: (fazaClass methodDictionary keys).			].				^ (res asSortedCollection).! !!MyObject class methodsFor: 'class methods' stamp: 'adan 3/3/2024 22:50'!behavesLike | behLikeSet fazaClass allInterfaces |behLikeSet := Set new."every interface behaves like itself"(self isInterface)	ifTrue: [		behLikeSet add: self.		].allInterfaces := Set new.behLikeSet addAll: (self instVarNamed: 'behavesLike')."traverse all that is behaved like recursively and add to our result"fazaClass := self.[(   (fazaClass isInterface)not) and:[((fazaClass = MyObject)not)] ] whileTrue:  [		fazaClass := fazaClass superclass. "increase the pointer"		behLikeSet addAll: fazaClass behavesLike.	].behLikeSet do: [:curInt |	"the current class is an interface so for every other interface:"	((self = curInt)not)	ifTrue: [		allInterfaces addAll: curInt behavesLike.		]	].behLikeSet addAll: allInterfaces.^behLikeSet.! !!MyObject class methodsFor: 'class methods' stamp: 'adan 3/3/2024 23:10'!isImplemented| childrenClass understandsAllFunctions allMeths  |(self isInterface)	ifFalse:[AssertionFailure signal: (self  asString), ' is not an interface!!'].childrenClass := Set new.allMeths := Set new.childrenClass := Set new.childrenClass:= (MyObject allSubclasses) asSet.(self behavesLike) do:[:faza | 	"each interface we behave like must also be implememnted for us to be implemented"	allMeths addAll: (faza methodDictionary keys)	].childrenClass do: [:chiiiild |				understandsAllFunctions:= true.				 (((chiiiild behavesLike) includes: self) and: [(chiiiild isInterface) not])				ifTrue: [ 					"the child is a regular class and not an interface and it implements the current interface"					(allMeths size = 0)						ifTrue: [^true].					allMeths do: [:method | "for each method in self"							(understandsAllFunctions and: [(chiiiild fazaImplementedMeth: method ) not]) 								ifTrue:[understandsAllFunctions := false]. "chiiiild doesnt understand this interface methods so go out!!!!"										].					(understandsAllFunctions)						ifTrue: [^true].					 ].			].^false.! !!MyObject class methodsFor: 'helperFuncs' stamp: 'adan 3/3/2024 23:05'!fazaImplementedMeth: selector 	"Answer whether the receiver can respond to the message whose selector 	is the argument. The selector can be in the method dictionary of the 	receiver's class or any of its superclasses."		"basically the understands method but it excludes interfaces"		((self isInterface)not)	ifTrue: [		(self includesSelector: selector) ifTrue: [			"Transcript show: 'is implemented in ', (self asString); cr."						^true].		].	(self = MyObject)	ifTrue:[		"if MyObject is reached, remember that you cannot keep using fazaImplementedMeth because it is not defined for actual classes that don't inherit from MyObject, like behaviour for example"		superclass == nil ifTrue: [^false].	^superclass canUnderstand: selector				].		superclass == nil ifTrue: [^false].		"for anybody wondering what faza is, it is a meme in which this guy called carrington and his friend chase imitate rich britich kids and how they speak"	^superclass fazaImplementedMeth: selector! !