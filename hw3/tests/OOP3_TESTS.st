TestCase subclass: #MyObjectTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3_TESTS'!!MyObjectTesting methodsFor: 'method8' stamp: 'Allan 2/28/2024 21:20'!testCompileInterface	self should: [Interface1 compile:'foo											'.		] raise: AssertionFailure description: 'Interfaces are not allowed to have methods that define behavior!!'.	self should: [Interface1 compile:'foo:											^self'.		] raise: AssertionFailure description: 'Interfaces are not allowed to have methods that define behavior!!'.	! !!MyObjectTesting methodsFor: 'method7' stamp: 'Allan 2/28/2024 21:18'!testInterfaceInitialize	self should: [Interface1 new.] raise: AssertionFailure description: 'Interfaces can not be instantiated!!'.	Object1 new.! !!MyObjectTesting methodsFor: 'method6' stamp: 'Allan 2/28/2024 21:59'!testAmbiguities	Interface6 compile: ('foo: arg1').	Interface6 compile: ('a').	Interface6 compile: ('ab').	Interface6 compile: ('foo').	Interface6 compile: ('foo: arg2 baz: arg3').		Interface5 compile: ('foo: arg1').	Interface5 compile: ('a').	Interface5 compile: ('ab').	Interface5 compile: ('foo').	Interface5 compile: ('foo: arg2 baz: arg3').		Interface3 compile: ('lolo').	Interface6 compile: ('lolo').	Interface2 compile: ('randomname').	Interface1 compile: ('randomname_1').	Interface2 compile: ('disaster').	Interface4 compile: ('disaster').		self assert: (((Object1 ambiguities) asString) = 'a SortedCollection()') .	self assert: (((Object2 ambiguities) asString) = 'a SortedCollection(#disaster)') .	self assert: (((Object3 ambiguities) asString) = 'a SortedCollection(#disaster)') .	self assert: (((Object4 ambiguities) asString) = 'a SortedCollection(#a #ab #disaster #foo #foo: #foo:baz: #lolo)') .								! !!MyObjectTesting methodsFor: 'method5' stamp: 'Allan 2/28/2024 22:06'!testIsImplemented	Object1 compile: ('Interface3Function	                               ^2.')	                where: #().	Object1 compile: ('Interface2Function	                               ^2.')	                where: #().		Object1 compile: ('Interface2FunctionSpeical							|temp |	                               temp := 1 + 2.						^temp.')	                where: #().		Object2 compile: ('Interface5Function						| temp |	                               temp := 2.						^(temp+temp).')	                where: #().	Object3 compile: ('Interface6Function						| temp |	                               temp := 2.						^(temp+temp).')	                where: #().		Object1 compile:('disaster							^self').	Object1 compile:('randomname							^self').								Object1 compile:('lolo							^self').		Object4 compile: ('foo: arg1							^self').	Object4 compile: ('a								^self').	Object4 compile: ('ab								^self').	Object4 compile: ('foo								^self').	Object4 compile: ('foo: arg2 baz: arg3								^self').		Interface1 compile: ('Interface1Function').	Interface2 compile: ('Interface2Function').	Interface3 compile: ('Interface3Function').	Interface4 compile: ('Interface4Function').	Interface5 compile: ('Interface5Function').	Interface6 compile: ('Interface6Function').	Interface2 compile: ('Interface2FunctionSpeical').		self assert: ((Interface1 isImplemented) = false).	self assert: (Interface2 isImplemented).	self assert: (Interface3 isImplemented).	self assert: ((Interface4 isImplemented) = false).	self assert: (Interface5 isImplemented).	self assert: (Interface6 isImplemented). 		self should: [Object1 isImplemented] raise: AssertionFailure description: 'Object1 is not an interface!!'.! !!MyObjectTesting methodsFor: 'method4' stamp: 'Allan 2/28/2024 22:07'!testBehavesLike	| behaves1 behaves2 behaves3 behaves4 ibehaves1 ibehaves2 ibehaves3 ibehaves4 ibehaves5 ibehaves6 |	behaves1 := Set new.	behaves2 := Set new.	behaves3 := Set new.	behaves4 := Set new.	behaves1 add: Interface1.	behaves1 add: Interface2.	behaves1 add: Interface3.	behaves2 add: Interface4.	behaves2 add: Interface3.	behaves2 add: Interface2.	behaves2 add: Interface1.	behaves3 add: Interface1.	behaves3 add: Interface2.	behaves3 add: Interface3.	behaves3 add: Interface4.	behaves4 add: Interface1.	behaves4 add: Interface2.	behaves4 add: Interface3.	behaves4 add: Interface4.	behaves4 add: Interface5.	behaves4 add: Interface6.	self assert: ((Object1 behavesLike) = behaves1).	self assert: ((Object2 behavesLike) = behaves2).	self assert: ((Object3 behavesLike) = behaves3).	self assert: ((Object4 behavesLike) = behaves4).			ibehaves1 := Set new.	ibehaves2 := Set new.	ibehaves3 := Set new.	ibehaves4 := Set new.	ibehaves5 := Set new.	ibehaves6 := Set new.	ibehaves1 add: Interface1.	ibehaves1 add: Interface2.	ibehaves1 add: Interface3.	ibehaves2 add: Interface2.	ibehaves3 add: Interface3.	ibehaves4 add: Interface4.	ibehaves4 add: Interface2.	ibehaves5 add: Interface5.	ibehaves5 add: Interface6.	ibehaves6 add: Interface6.		self assert: ((Interface1 behavesLike) = ibehaves1).	self assert: ((Interface2 behavesLike) = ibehaves2).	self assert: ((Interface3 behavesLike) = ibehaves3).	self assert: ((Interface4 behavesLike) = ibehaves4).	self assert: ((Interface5 behavesLike) = ibehaves5).	self assert: ((Interface6 behavesLike) = ibehaves6).			! !!MyObjectTesting methodsFor: 'method3' stamp: 'Allan 2/28/2024 20:49'!testIsInterface	self assert: (Interface1 isInterface).	self assert: ((Object1 isInterface) = false).! !!MyObjectTesting methodsFor: 'method2' stamp: 'Allan 2/28/2024 21:20'!testMethod2	self assert: ((Object1 isInterface) = false).! !!MyObjectTesting methodsFor: 'method1' stamp: 'Allan 2/28/2024 20:48'!testMethod1	|behavesLikeSet |self should: [Object1 subclass: #InvalidInterfaceInheritance	isInterface: true	behavesLike: {}	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'] raise: AssertionFailure description: 'Interfaces must derive from MyObject!!'.self should: [MyObject subclass: #InvalidInterfaceState	isInterface: true	behavesLike: {}	instanceVariableNames: '    a   '	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'] raise: AssertionFailure description: 'Interfaces can not have state!!'.self should: [Interface1 subclass: #InvalidClassInheritance	isInterface: false	behavesLike: {}	instanceVariableNames: '    a   '	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'] raise: AssertionFailure description: 'Classes can not derive from an interface!!'.behavesLikeSet := Set new.behavesLikeSet add: Interface1.behavesLikeSet add: Interface2.behavesLikeSet add: Object2.behavesLikeSet add: Interface3.self should: [MyObject subclass: #InvalidBehavesLike	isInterface: false	behavesLike: behavesLikeSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'] raise: AssertionFailure description: 'Can not behave like a non-interface!!'.! !!MyObjectTesting methodsFor: 'Part1 - Compile:where:' stamp: 'Allan 2/28/2024 21:26'!testCompileMethodWithCorrectTypes"Test the method compiles and executes correctly with correct argument types."    Object3 compile: ('testMethod: aNumber	                                | tempVar |	                                tempVar := aNumber + 1. ^tempVar.')	                where: #(Number).	    self assert: (Object3 new testMethod: 1) equals: 2.	Object3 compile: ('testMethod: aNumber anotherArg: aString	                                | tempVar |	                                tempVar := aNumber + 1. ^tempVar.')	                where: #(Number String).	    self assert: (Object3 new testMethod: 1 anotherArg: 'Hello') equals: 2.	Object1 compile: ('noArgs1	                               ^2.')	                where: #().	    self assert: (Object1 new noArgs1) equals: 2.	Object2 compile: ('noArgs2						| temp |	                               temp := 2.						^(temp+temp).')	                where: #().	    self assert: (Object2 new noArgs2) equals: 4.	Object3 compile: ('noArgs3						| temp |	                               temp := 2.						^(temp+temp).')	                where: #().	    self assert: (Object3 new noArgs3) equals: 4.	Object4 compile: ('noArgs4						| temp |	                               temp := 2.						^(temp+temp).')	                where: #().	    self assert: (Object4 new noArgs4) equals: 4.! !!MyObjectTesting methodsFor: 'Part1 - Compile:where:' stamp: 'Allan 2/28/2024 20:46'!testCompileMethodWithIncorrectArgumentCount"Test the method compilation fails due to incorrect number of constraints." 	self should: [Object1 compile: 'testMethod: aNumber anotherArg: anotherNumber                                                 | tempVar |                                                tempVar := aNumber + anotherNumber. ^tempVar.'                                where: #(Number)] raise: AssertionFailure.	self should: [Object1 compile: 'testMethod: aNumber anotherArg: anotherNumber                                                 | tempVar |                                                tempVar := aNumber + anotherNumber. ^tempVar.'                                where: #()] raise: AssertionFailure.	self should: [Object1 compile: 'testMethod: aNumber anotherArg: anotherNumber                                                 | tempVar |                                                tempVar := aNumber + anotherNumber. ^tempVar.'                                where: #(Number Number Number)] raise: AssertionFailure.! !!MyObjectTesting methodsFor: 'Part1 - Compile:where:' stamp: 'Allan 2/28/2024 21:28'!testTypeCheckFailsAtRuntime    "Test that the method raises an exception if an argument of the wrong type is passed."        self should: [Object3 new testMethod: 'hello'] raise: AssertionFailure description: 'Type mismatch!! Argument 1 should be Number'.        self should: [Object3 new testMethod: 123 anotherArg: 123] raise: AssertionFailure description: 'Type mismatch!! Argument 2 should be String'.! !